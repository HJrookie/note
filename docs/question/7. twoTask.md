#### runtime
JavaScript 有一个基于事件循环`event loop`的运行时模型`runtime model`，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。这个模型与其他语言中的模型截然不同，比如 C 和 Java。
#### 模型简介
主要包含一下几个内容,栈,堆,队列;  
- 栈   --- 函数调用形成了一个由若干帧组成的栈    
- 堆   --- 对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。  
- 队列 --- task 队列和 microtask 队列  
<!-- #### html 标准里的 event loop
[html 标准](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops) -->
#### 多个 runtime 通信
一个web worker or a cross-origin iframe has its own stack, heap, and message queue. 两个不同的 runtime只能通过postMessage来通信

### 微任务,宏任务
macrotasks:  `setTimeout, setInterval, setImmediate, I/O, UI rendering `  
microtasks:  `process.nextTick, Promise, **MutationObserver** `  
#### 执行顺序 
先把微任务里面的执行完,就算里面东西很多,事儿很多.然后再去执行宏任务中的东西;微任务优先级最高;  
> 换句话说,JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。

#### nodejs  [文章](https://notes.andywu.tw/2020/%E5%AE%8C%E6%95%B4%E5%9C%96%E8%A7%A3node-js%E7%9A%84event-loop%E4%BA%8B%E4%BB%B6%E8%BF%B4%E5%9C%88/)
1. `process.nextTick()`   
2. `Promise.resolve().then(CALLBACK)`    
3. `setTimeout/interval/Immediate/oncallback/轮询/`

![image](https://user-images.githubusercontent.com/27692261/227455191-ce68c583-3438-43ca-8d8c-20cd8c9a7ef7.png)

定时器  
`会被丢到这个queue的事件有setTimeout()跟setInterval()，当所设定的时间倒数完毕时，计时器的callback会被丢来这里等待执行。`

挂起的回调  
`这个queue主要是给作业系统层级使用的，像是传输过程中的TCP errors，socket连线收到了ECONNREFUSED，他的callback就会被丢来这里。`

空闲，准备  
`这个queue连官方的文件都是说给内部使用的，并没有在文件中多做说明，所以这个queue可以先忽略。`

轮询  
`当Node.js的app在运行时有新的I/O资料进来可以被读取时，例如会用到串流有提供的.on('data', callback)，这时他的callback就会被放在这个queue等待被执行。`

查看  
`还记得我们有一个也是有关时间的setImmediate()还没讲到，他的callback就是排在这里的。`

关闭回调  
`当我们今天需要关闭连线、档案等等的操作时，例如socket.on('close', callback)，只要是有关"关闭"的动作的callback就会来这里。`