#### runtime
JavaScript 有一个基于事件循环`event loop`的运行时模型`runtime model`，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。这个模型与其他语言中的模型截然不同，比如 C 和 Java。
#### 模型简介
主要包含一下几个内容,栈,堆,队列;  
- 栈   --- 函数调用形成了一个由若干帧组成的栈    
- 堆   --- 对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。  
- 队列 --- task 队列和 microtask 队列  


<!-- #### html 标准里的 event loop
[html 标准](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops) -->
#### 多个 runtime 通信
一个web worker or a cross-origin iframe has its own stack, heap, and message queue. 两个不同的 runtime只能通过postMessage来通信

### 微任务,宏任务
macrotasks:  `setTimeout, setInterval, setImmediate, I/O, UI rendering `  
microtasks:  `process.nextTick, Promise, **MutationObserver** `  
#### 执行顺序 
先把微任务里面的执行完,就算里面东西很多,事儿很多.然后再去执行宏任务中的东西;微任务优先级最高;  
> 换句话说,JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。
#### 为啥要用 microtask？  
根据HTML Standard，在每个 task 运行完以后，UI 都会重渲染，  
那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。  
反之如果新建一个 task 来做数据更新，task运行完再更新ui,那么渲染就会进行两次。  


#### 比较简单的例子  
```js
setTimeout(() => {
    console.log('1');
    Promise.resolve().then(() => {
        console.log('2');  // 这里可以看出来 .then 里面的代码会立即加入到微任务,但是并不会立马执行
    });
    console.log(3);
}, 0);
setTimeout(() => {
    console.log('4');
}, 0);
console.log('5');
```

#### 稍微复杂的例子
> 复杂的点在于,要整理清楚 微任务和宏任务的切换
```js
Promise.resolve().then(() => {
  console.log(' 1');
  const timer2 = setTimeout(() => {
    console.log('2')
  }, 0)
});
const timer1 = setTimeout(() => {
  console.log('3')
  Promise.resolve().then(() => {
    console.log('4')
  })
}, 0)
console.log('5');
```

### 更复杂例子
```js
console.log(1);
Promise.resolve()
    .then(() => {
        console.log(7);
        Promise.resolve()
            .then(() => {
                console.log('2');
            })
            .then(() => {
                sleep(3);
                console.log(6);
            });
        console.log(8);
    })
    .then(() => { 
        console.log('3');
    });

console.log(4);
setTimeout(() => {
    console.log(5);
}, 100);
let sleep = t =>{
    let time = Date.now();
    while(Date.now() - time <t * 1000){}
}

// 1 4 7 8 2 3  3s 6 5 解析在下面
/*
1. 先打印 1 , 4 , 然后把第一个.then 里面的内容放到微任务队列,把 5 放到宏任务队列
2. 执行微任务队列里的内容,即打印 7,8,把 2 放到微任务队列,再把 3 放到微任务队列,
3. 执行打印 2,然后把 sleep3 放到微任务队列,然后执行打印 3
4. sleep3,打印 6 , 5
*/


```

#### 例子2
```js
console.log(1)
Promise.resolve().then(()=>{
    console.log(2)
}).then(()=>{
    setTimeout(()=>{
    console.log(5)
},0)
})
console.log(3)
setTimeout(()=>{
    console.log(4) 
},0)

// 1 3 2 4 5
```

#### 例子3
```js
console.log(1)
Promise.resolve().then(() => {
  Promise.resolve().then(() => {
    console.log("2")  // 这里第 1
  }).then(() => {
    
    console.log(6)  // 第3
  }) 
}).then(() => {
  console.log("3")   // 第 2

Promise.resolve().then(() => {
    console.log("7")  // 第4
  }).then(() => {
    console.log(8)  //第5
  }) 
})
console.log(4)

let r = setTimeout(() => {
  console.log(5)
}, 0)

function sleep(delay) {
  let time = new Date();
  while (new Date() - time < delay * 1000) {}
}
// 1 4 2 3 6 7 8 5 
```


### 比较难的一个例子 需要细心
```js
console.log(1)
setTimeout(()=>{console.log(2)},0)
new Promise((resolve,reject)=>{
    console.log(3)
    setTimeout(()=>{console.log(8)},0)
    new Promise((resolve,reject)=>{
       setTimeout(()=>{console.log(9)},0)
    console.log(7)
    resolve()
    console.log(11)
})
.then(()=>{
    console.log(10)
})
 console.log(12)
    resolve()
 console.log(13)
})
.then(()=>{
    console.log(4)
})
setTimeout(()=>{console.log(5)},0)
console.log(6)




 1 3 7 11 12 13 6 10 4 2 8 9 5 
 // .then里的必须resolve才能执行  
 new Promise里的同步代码立即执行.  
 里面的setTimeout会被放到宏任务队列里,.then里的被放到微任务队列.代码从上到下执行.  
 这一大坨代码执行完了之后,才会去看微任务队列里有没有东西,如果有,把里面的东西执行完,  
 再去看宏任务队列
```


#### 加上 await
```js
async function async1() {
  console.log("1");
  await async2(); // 这个语句相当于 async2 被 promise 包裹直接执行,后面的那个语句被放在.then 里面

    new Promise((res) => {
        async2();
    }).then((res) => {
        console.log("2");
    });

  console.log("2");
}
async function async2() {
  console.log("3");
}
async1();
console.log('4')
//   1 3 4 2



 // 修改上面的代码
async function async1() {
    console.log("1");
    await async2();
    console.log("2");
}
async function async2() {
    console.log("3");
}
await async1(); // 在这里加 await 然后顺序就变了
console.log("4");
// 1 3 2 4 
```



#### await 例2
```js
async function async1() {
    console.log("1");
    await async2();
    console.log("2");  // 这个后被放到微任务队列
}
async function async2() {
    console.log("3");
    new Promise((res) => {
        res(5);
    }).then((res) => {
        console.log(6); // 这个会先被放到微任务队列
    });
    console.log(7);
}
async1();
console.log("4");
// 1 3 7 4 6 2
```

#### await 例3 
```js
async function async1() {
    console.log("1");
    await new Promise((resolve) => {
        // resolve(2) //这个 promise 没有被 resolve 的话,那么 4,5 就都不会被打印
        console.log("3");
    });
    console.log("4");  // 这个会比 5 先打印,因为它相当于 Promise.resove().then()这里面的语句会立马被放到微任务队列里
    return "5";
}
console.log("6");
async1().then((res) => console.log(res));
console.log("7");

// 6 1 3 7 4 5
```

#### 一个比较复杂的 async await 例子
```js
async function testSometing() {
  console.log("1");
  return "2";
}

async function testAsync() {
  console.log("3");
  return Promise.resolve("4");
}

async function test() {
  console.log("5...");
  const v1 = await testSometing();
  console.log(v1);
  const v2 = await testAsync();
  console.log(v2);
  console.log(v1, v2);
}

test();  //  如果在这里加 await 那就是  5 1 2 3 4  24 6 8 7 

var promise = new Promise(resolve => {
  console.log("6...");
  resolve("7");
});
promise.then(val => console.log(val));
console.log("8.");
//  5  1  6  8  2 3 7 4   24
```

#### await 错误处理
```js
async function async1 () {
  try {
    await Promise.reject('error!!!') // await 后面跟的报错了,需要在外面有 try-catch  
  } catch(e) {
    console.log(e)
  }
  return Promise.resolve('async1 success')
}
async1().then(res => console.log(res))
// 如果不用 await 那就  在后面跟.then .catch 就行
```