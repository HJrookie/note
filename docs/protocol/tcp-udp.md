
### TCP,UDP

TCP: 面向连接的,三次握手,四次挥手,保证数据正确以及数据顺序,要求资源较多,面向字节流 只支持 1 对一的.,  
UDP: 无连接,尽最大努力交付的,可能会丢包,顺序会乱,需求资源少,面向报文,支持 1 对 1,1 对多,多对 1,多对多

#### TCP [blog](https://blog.csdn.net/qzcsu/article/details/72861891)
ip层可以保证数据包在两个主机之间正确传递,但是实际通信的双方其实是主机上的进程,因此 端到端通信才是进程之间的通信(endpoint)  
> 每一条TCP连接都有两个端点，这种端点我们叫作套接字（socket），ip+端口就是套接字 192.3.4.16:80。  
> tcp 报文首部里面有许多位,主要包含以下(源端口和目的端口,序号(seq),确认号(ack),确认(ACK),推送(PSH),复位(RST),同步(SYN),终止(FIN),紧急(URG),校验和...)  
> SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；




> ack 代表自己期望收到包的的序号  
> 同步SYN，在连接建立时用来同步序号  
> 仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；   

0. 最开始都是 closed 状态,然后 server 先进入 listen 状态
1. client 发送连接请求报文, 同步位 SYN =1, 序号 seq = x, 进入 SYN-SENT 状态 TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
2. server 收到之后,如果同意连接,则发出确认报文; ACK=1,SYN=1, ack = x+1,seq = y TCP 服务器进程进入了 SYN-RCVD 状态
3. TCP 客户进程收到确认后，还要向服务器给出确认。确认报文的 ACK=1，ack=y+1，自己的序列号 seq=x+1，此时，TCP 连接建立，客户端进入 ESTABLISHED（已建立连接）状态
4. 当服务器收到客户端的确认后也进入 ESTABLISHED 状态，此后双方就可以开始通信了
   ![流程](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA1MTEwNDA1NjY2?x-oss-process=image/format,png)

#### 为什么 TCP 客户端最后还要发送一次确认呢？

一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

> 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

> 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

#### 四次挥手

![流程](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format,png)

> 数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。


为什么客户端最后还要等待2MSL？  
MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。 `去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。`  
当 server 发送 FIN 时,是不能直接释放 server 的资源的,必须要等到 client 的确认才可以释放资源.  当 Client 收到 FIN时,会回复 ACK,但是 client 不能确定  
server 是否收到了 ACK, 如果收到了,那么通信结束,没收到的话,Server 就会重新发 FIN,因此 Client 是必须等待结果的.为什么是 2msl 呢? `ack 丢+FIN重发`  
那么 client 如果不等呢? 会导致 server 可能未收到 ack,一直等待,或server 重发 Fin 后,未被处理,或者又和新 server 建立了链接,又收到旧 server 的包   



第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

------------------------

为什么建立连接是三次握手，关闭连接确是四次挥手呢？  

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

如果已经建立了连接，但是客户端突然出现故障了怎么办？  
TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
